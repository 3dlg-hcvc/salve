

from dataclasses import dataclass
from typing import Dict, List, NamedTuple, Tuple

import gtsam
import numpy as np



class SlamMeasurement(NamedTuple):
    """2d measurements."""

    i: int  # camera index
    wdo_idx: int  # 2d measurement


@dataclass
class SlamFeatureTrack2d:
    slam_measurements: List[SlamMeasurement]


    @staticmethod
    def generate_tracks_from_pairwise_matches(matches_dict: Dict[Tuple[int, int], np.ndarray]) -> List["SlamFeatureTrack2d"]:
        """Factory function that creates a list of tracks from 2d point correspondences.
        Creates a disjoint-set forest (DSF) and 2d tracks from pairwise matches. We create a singleton for union-find
        set elements from camera index of a detection and the index of that detection in that camera's keypoint list,
        i.e. (i,k).
        Args:
            matches_dict: Dict of pairwise matches of type:
                    key: pose indices for the matched pair of images
                    val: feature indices, as array of Nx2 shape; N being nb of features. A row is (feature_idx1,
                         feature_idx2).
            keypoints_list: List of keypoints for each image.
        Returns:
            list of all valid SfmTrack2d generated by the matches.
        """
        # Generate the DSF to form tracks
        dsf = gtsam.DSFMapIndexPair()
        track_2d_list = []
        # for DSF finally
        # measurement_idxs represented by ks
        for (i1, i2), k_pairs in matches_dict.items():
            for (k1, k2) in k_pairs:
                dsf.merge(gtsam.IndexPair(i1, k1), gtsam.IndexPair(i2, k2))

        key_set = dsf.sets()

        # create a landmark map: a list of tracks
        # Each track is represented as a list of (camera_idx, measurements)
        for set_id in key_set:
            index_pair_set = key_set[set_id]  # key_set is a wrapped C++ map, so this unusual syntax is required

            # Initialize track from measurements
            track_measurements = []
            for index_pair in gtsam.IndexPairSetAsArray(index_pair_set):
                # camera_idx is represented by i
                # measurement_idx is represented by k
                i = index_pair.i()
                k = index_pair.j()
                # add measurement in this track
                track_measurements += [SlamMeasurement(i, k)]

            track_2d = SlamFeatureTrack2d(track_measurements)
            track_2d_list += [track_2d]

        return track_2d_list


def test_generate_tracks_from_pairwise_matches() -> None:
    """Set up correspondences for each (i1,i2) pair. There should be 4 tracks, since we get one chained track as
    (i=0, k=0) -> (i=1, k=2) -> (i=2,k=3).
    """
    dummy_matches_dict = {
        (0, 1): np.array([[0, 2]]),
        (1, 2): np.array([[2, 3], [4, 5], [7, 9]]),
        (0, 2): np.array([[1, 8]]),
    }

    tracks_2d = SlamFeatureTrack2d.generate_tracks_from_pairwise_matches(dummy_matches_dict)
    import pdb; pdb.set_trace()


